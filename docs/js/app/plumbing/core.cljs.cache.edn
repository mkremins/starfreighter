{:rename-macros {}, :renames {}, :use-macros {lazy-get plumbing.core, for-map plumbing.core, -unless-update plumbing.core}, :excludes #{update}, :name plumbing.core, :imports nil, :requires {schema-utils schema.utils, schema.utils schema.utils, schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema}, :uses nil, :defs {dissoc-in {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 96, :column 7, :end-line 96, :end-column 16, :arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level)."}, :name plumbing.core/dissoc-in, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 16, :method-params ([m p__11262]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 96, :end-line 96, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level)."}, rsort-by {:name plumbing.core/rsort-by, :file "target/app/plumbing/core.cljs", :line 290, :column 1, :end-line 290, :end-column 14, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 290, :column 6, :end-line 290, :end-column 14}, :doc "Like sort-by, but prefers higher values rather than lower ones."}, +none+ {:name plumbing.core/+none+, :file "target/app/plumbing/core.cljs", :line 16, :column 1, :end-line 16, :end-column 22, :private true, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 16, :column 16, :end-line 16, :end-column 22, :private true}, :doc "A sentinel value representing missing portions of the input data."}, millis {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 373, :column 7, :end-line 373, :end-column 13, :arglists (quote ([]))}, :name plumbing.core/millis, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 13, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 373, :end-line 373, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, swap-pair! {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 356, :column 7, :end-line 356, :end-column 17, :arglists (quote ([a f] [a f & args])), :doc "Like swap! but returns a pair [old-val new-val]", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([a f]), :arglists ([a f] [a f & args]), :arglists-meta (nil nil)}}, :name plumbing.core/swap-pair!, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([a f]), :arglists ([a f] [a f & args]), :arglists-meta (nil nil)}, :method-params ([a f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 356, :end-line 356, :max-fixed-arity 2, :fn-var true, :arglists ([a f] [a f & args]), :doc "Like swap! but returns a pair [old-val new-val]"}, keywordize-map {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 107, :column 7, :end-line 107, :end-column 21, :arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string"}, :name plumbing.core/keywordize-map, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 107, :end-line 107, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string"}, get-and-set! {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 368, :column 7, :end-line 368, :end-column 19, :arglists (quote ([a new-val])), :doc "Like reset! but returns old-val"}, :name plumbing.core/get-and-set!, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 19, :method-params ([a new-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 368, :end-line 368, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-val])), :doc "Like reset! but returns old-val"}, positions {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 214, :column 7, :end-line 214, :end-column 16, :arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))"}, :name plumbing.core/positions, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 16, :method-params ([f s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 214, :end-line 214, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))"}, sum {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 197, :column 7, :end-line 197, :end-column 10, :arglists (quote ([f xs] [xs])), :doc "Return sum of (f x) for each x in xs", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f xs] [xs]), :arglists ([f xs] [xs]), :arglists-meta (nil nil)}}, :name plumbing.core/sum, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f xs] [xs]), :arglists ([f xs] [xs]), :arglists-meta (nil nil)}, :method-params ([f xs] [xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 197, :end-line 197, :max-fixed-arity 2, :fn-var true, :arglists ([f xs] [xs]), :doc "Return sum of (f x) for each x in xs"}, conj-when {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 275, :column 7, :end-line 275, :end-column 16, :arglists (quote ([coll x] [coll x & xs])), :doc "Like conj but ignores non-truthy values", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll x]), :arglists ([coll x] [coll x & xs]), :arglists-meta (nil nil)}}, :name plumbing.core/conj-when, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll x]), :arglists ([coll x] [coll x & xs]), :arglists-meta (nil nil)}, :method-params ([coll x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 275, :end-line 275, :max-fixed-arity 2, :fn-var true, :arglists ([coll x] [coll x & xs]), :doc "Like conj but ignores non-truthy values"}, distinct-by {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 239, :column 7, :end-line 239, :end-column 18, :arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned"}, :name plumbing.core/distinct-by, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 18, :method-params ([f xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 239, :end-line 239, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned"}, safe-get-in {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 136, :column 7, :end-line 136, :end-column 18, :arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found"}, :name plumbing.core/safe-get-in, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 18, :method-params ([m ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 136, :end-line 136, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found"}, indexed {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 209, :column 7, :end-line 209, :end-column 14, :arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s"}, :name plumbing.core/indexed, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 209, :end-line 209, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s"}, cons-when {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 285, :column 7, :end-line 285, :end-column 16, :arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy."}, :name plumbing.core/cons-when, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 16, :method-params ([x s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 285, :end-line 285, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy."}, mapply {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 377, :column 7, :end-line 377, :end-column 13, :arglists (quote ([f m] [f arg & args])), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([f m]), :arglists ([f m] [f arg & args]), :arglists-meta (nil nil)}}, :name plumbing.core/mapply, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([f m]), :arglists ([f m] [f arg & args]), :arglists-meta (nil nil)}, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 377, :end-line 377, :max-fixed-arity 2, :fn-var true, :arglists ([f m] [f arg & args]), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply."}, map-keys {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 79, :column 7, :end-line 79, :end-column 15, :arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m"}, :name plumbing.core/map-keys, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 79, :end-line 79, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m"}, interleave-all {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 260, :column 7, :end-line 260, :end-column 21, :arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(colls)], :arglists ([& colls]), :arglists-meta (nil)}}, :name plumbing.core/interleave-all, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(colls)], :arglists ([& colls]), :arglists-meta (nil)}, :method-params [(colls)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 260, :end-line 260, :max-fixed-arity 0, :fn-var true, :arglists ([& colls]), :doc "Analogy: partition:partition-all :: interleave:interleave-all"}, update {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 55, :column 8, :end-line 55, :end-column 14, :arglists (quote ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs])), :doc "Updates the value in map m at k with the function f.\n\n    Like update-in, but for updating a single top-level key.\n    Any additional args will be passed to f after the value.\n\n    WARNING As of Clojure 1.7 this function exists in clojure.core and\n    will not be exported by this namespace.", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([m k f] [m k f x1] [m k f x1 x2]), :arglists ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs]), :arglists-meta (nil nil nil nil)}}, :name plumbing.core/update, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([m k f] [m k f x1] [m k f x1 x2]), :arglists ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs]), :arglists-meta (nil nil nil nil)}, :method-params ([m k f] [m k f x1] [m k f x1 x2]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 2, :line 55, :end-line 55, :max-fixed-arity 5, :fn-var true, :arglists ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs]), :doc "Updates the value in map m at k with the function f.\n\n    Like update-in, but for updating a single top-level key.\n    Any additional args will be passed to f after the value.\n\n    WARNING As of Clojure 1.7 this function exists in clojure.core and\n    will not be exported by this namespace."}, grouped-map {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 160, :column 7, :end-line 160, :end-column 18, :arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected."}, :name plumbing.core/grouped-map, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 18, :method-params ([key-fn map-fn coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 160, :end-line 160, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected."}, count-when {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 270, :column 7, :end-line 270, :end-column 17, :arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds"}, :name plumbing.core/count-when, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 17, :method-params ([pred xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 270, :end-line 270, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds"}, aconcat {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 175, :column 7, :end-line 175, :end-column 14, :arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) "}, :name plumbing.core/aconcat, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 175, :end-line 175, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) "}, singleton {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 202, :column 7, :end-line 202, :end-column 16, :arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element"}, :name plumbing.core/singleton, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 16, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 202, :end-line 202, :max-fixed-arity 1, :fn-var true, :arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element"}, map-from-keys {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 86, :column 7, :end-line 86, :end-column 20, :arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks"}, :name plumbing.core/map-from-keys, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 20, :method-params ([f ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 86, :end-line 86, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks"}, map-vals {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 68, :column 7, :end-line 68, :end-column 15, :arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type"}, :name plumbing.core/map-vals, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 68, :end-line 68, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type"}, assoc-when {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 143, :column 7, :end-line 143, :end-column 17, :arglists (quote ([m & kvs])), :doc "Like assoc but only assocs when value is truthy", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(m kvs)], :arglists ([m & kvs]), :arglists-meta (nil)}}, :name plumbing.core/assoc-when, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(m kvs)], :arglists ([m & kvs]), :arglists-meta (nil)}, :method-params [(m kvs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 143, :end-line 143, :max-fixed-arity 1, :fn-var true, :arglists ([m & kvs]), :doc "Like assoc but only assocs when value is truthy"}, map-from-vals {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 91, :column 7, :end-line 91, :end-column 20, :arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs"}, :name plumbing.core/map-from-vals, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 20, :method-params ([f vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 91, :end-line 91, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs"}, update-in-when {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 152, :column 7, :end-line 152, :end-column 21, :arglists (quote ([m key-seq f & args])), :doc "Like update-in but returns m unchanged if key-seq is not present.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(m key-seq f args)], :arglists ([m key-seq f & args]), :arglists-meta (nil)}}, :name plumbing.core/update-in-when, :variadic true, :file "target/app/plumbing/core.cljs", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 3, :method-params [(m key-seq f args)], :arglists ([m key-seq f & args]), :arglists-meta (nil)}, :method-params [(m key-seq f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 3, :fn-var true, :arglists ([m key-seq f & args]), :doc "Like update-in but returns m unchanged if key-seq is not present."}, unchunk {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 180, :column 7, :end-line 180, :end-column 14, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci"}, :name plumbing.core/unchunk, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 180, :end-line 180, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci"}, safe-get {:protocol-inline nil, :meta {:file "/Users/mkremins/Projects/starfreighter/target/app/plumbing/core.cljs", :line 129, :column 7, :end-line 129, :end-column 15, :arglists (quote ([m k])), :doc "Like get but throw an exception if not found"}, :name plumbing.core/safe-get, :variadic false, :file "target/app/plumbing/core.cljs", :end-column 15, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 129, :end-line 129, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :doc "Like get but throw an exception if not found"}}, :require-macros {plumbing.core plumbing.core, schema-macros schema.macros, schema.macros schema.macros, schema-utils schema.utils, schema.utils schema.utils, schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema}, :cljs.analyzer/constants {:seen #{:plumbing.core/missing :else}, :order [:plumbing.core/missing :else]}, :doc "Utility belt for Clojure in the wild"}